
########################################################################
# Utility functions
########################################################################

defineReplace(normalizePath) {
	path = $$1
	path = $$replace(path, /+, /)
	path = $$replace(path, /$, )
	path = $$replace(path, \\\\+, /)
	win32 {
		path = $$lower($$path)
	}
	return($$path)
}

defineTest(addCommand) {
	cmdvar = $$1
	command = $$2
	isEmpty($$cmdvar) {
		$$cmdvar = $$command
	} else {
		$$cmdvar += $$escape_expand(\\n\\t)$$command
	}
	export($$cmdvar)
}

########################################################################
# Dependency management functions
########################################################################

##
# This function allows to protect a block from being parsed more than once in
# the include tree.
#
# Parameters:
#		name		a unique name associated with this block (eg: using $$__FILE__ as
#						argument will ensure this block will only be read once for the given file)
#
defineTest(includeOnce) {
	projectFile = $$basename(1)
	projectName = $$replace(projectFile, \\., _)
	projectName = $$replace(projectName, -, _)

	defined = $$eval($${projectName}.defined)
	path = $$eval($${projectName}.path)

	equals(defined, true) : equals(path, $$_PRO_FILE_) {
		return(false)
	} else {
		eval($${projectName}.defined = true)
		eval($${projectName}.path = $$1)
		export($${projectName}.defined)
		export($${projectName}.path)
		return(true)
	}
}

defineReplace(canonicalize) {
	filelist = $$1
	filelist = $$replace(filelist, "/{2,}", /)
	filelist = $$replace(filelist, /\\.\\.(?=/), /@)
	for(iteration, 1..100) {
		newfilelist = $$replace(filelist, /[^@/]+/@(?=/), )
		equals(filelist, $$newfilelist) {
			filelist = $$newfilelist
			break()
		}	else {
			filelist = $$newfilelist
		}
	}
	return($$filelist)
}

defineReplace(toWindowsPath) {
	path = $$replace(1, /+, \\)
	return($$path)
}

##
# This function activates the compilation of the specified artifact if available.
# If it is not available for compilation it looks for an installed version, and
# will complains if the artifact is missing.
#
defineTest(addInstallableSubdir) {
	artifact = $$1
	dir  = $$2
	deps = $$3
	for(subdirs, dir) {
		entries = $$files($$subdirs)
		for(entry, entries) {
			name = $$replace(entry, [/\\\\\\.], _)
			SUBDIRS += $$name
			
			hasFlag($${artifact},file) {
				eval  ($${name}.file = $$entry)
				export($${name}.file)
			} else {
				eval  ($${name}.subdir = $$entry)
				export($${name}.subdir)
			}

			eval ($${name}.depends = $$replace(deps, [/\\\\\\.], _))
			export($${name}.depends)
		}
	}
	
	export(SUBDIRS)
}

##
# This function configures the current artifact build parameters to compile and
# link using the specified library installed on the system.
# A feature file must describe the build parameters, it can be local or installed. 
#
# Parameters:
#		name		the name of the library
#		feature	the path to the feature file relative to the root source directory.
#
# The feature file can directly modify INCLUDEPATH and LIBS variables. If other
# variables needs to be modified, the feature file will have to call export(VAR)
# on them.
defineTest(requireLib) {
	
	name = $$1
	feature = $$2
	isEmpty(name)   : error(missing name parameter in requireLib)
	isEmpty(feature): error(missing feature parameter in requireLib)

	#message(Using system lib $$name)

	featureNoExt = $$replace(feature, ^(.+)\\.prf$, \\1)
	hasFlag($$name,src) {
		dir = $$dirname(feature)
		MY_FEATUREFILE = $$ROOT_SRC_DIR/$$featureNoExt
	} else {
		!hasFlag($$name,installed) {
			error(requireLib: Cannot feature file for $$name)
		}
		MY_FEATUREFILE = $$FEATURES_DIR/$$basename(featureNoExt)
	}
	load($$MY_FEATUREFILE)

	export(INCLUDEPATH)
	export(DEPENDPATH)
	export(LIBS)
}

##
# This function configures the current artifact build parameters to compile and
# link using the specified library.
# It can work either when sources are available in the same source tree as the
# client artifact, or when just the installed version is available.
#
# Parameters:
#		name	the name of the library
#		dir		the subdirectory from include tree root and/or source tree root
#
# This function makes several assumption by default to configure the include path,
# library path and library name. Nevertheless, you can customize things in the
# library feature file. This file should be named <name>.prf file and created in
# the  <dir> directory of your source tree.
# In this file, you can set MY_INCLUDEPATH, MY_LIBRARYPATH and MY_LIBS variables
# to override default values. You can also define other variables, but you
# will have to export them using export(VAR)
#
defineTest(requireExtLib) {
	
	name = $$1
	project  = $$2
	isEmpty(name)   : error(missing name parameter in requireExtLib)
	isEmpty(project): error(missing project parameter in requireExtLib)

	OLD_INCLUDEPATH = $$INCLUDEPATH
	OLD_LIBS = $$LIBS

	hasFlag($$name,file) {
		dir = $$dirname(project)
	} else {
		dir = $$project
	}

	hasFlag($$name,src) {
		#message(Using shipped version of $$name in $$dir)
		MY_FEATUREFILE = $$ROOT_SRC_DIR/$$dir/$${name}
		MY_INCLUDEPATH = $$ROOT_SRC_DIR/$$dir
		MY_LIBRARYPATH = -L$$LIB_DESTDIR
	} else {
		!hasFlag($$name,installed) {
			error(requireExtLib: Cannot find $$name library)
		}
		#message(Using installed version of $$name)
		MY_FEATUREFILE = $$FEATURES_DIR/$${name}
		MY_INCLUDEPATH = $$SOFA_INSTALL_INC_DIR/$$dir
		MY_LIBRARYPATH = -L$$SOFA_INSTALL_LIB_DIR
	}
	MY_LIBS = -l$$name$$LIBSUFFIX

	load($$MY_FEATUREFILE)

	equals(OLD_INCLUDEPATH, $$INCLUDEPATH) {
		INCLUDEPATH *= $$MY_INCLUDEPATH
		DEPENDPATH *= $$MY_INCLUDEPATH
	}
	equals(OLD_LIBS, $$LIBS) {
		LIBS *= $$MY_LIBRARYPATH $$MY_LIBS
	}

	export(DEPENDPATH)
	export(INCLUDEPATH)
	export(LIBS)
}

##
# This function configures the current artifact build parameters to compile and
# link using the specified SOFA library.
# It can work either when sources are available in the same source tree as the
# client artifact, or when just the installed version is available.
#
# Parameters:
#		name	the name of the library
#		dir		the subdirectory from include tree root and/or source tree root
#
defineTest(requireSofaLib) {
	name = $$1
	project = $$2
	isEmpty(name)   : error(missing name parameter in requireSofaLib)
	isEmpty(project): error(missing project parameter in requireSofaLib)

	sourcedir = $$replace(project, (applications|framework|modules)/.+, \\1)

	hasFlag($$name,src) {
		#message(Using shipped version of Sofa library: $$name)
		INCLUDEPATH *= $$ROOT_SRC_DIR/$$sourcedir
		DEPENDPATH *= $$ROOT_SRC_DIR/$$sourcedir
		LIBS *= -L$$LIB_DESTDIR
	} else {
		#message(Using installed version of Sofa library: $$name)
		INCLUDEPATH *= $$SOFA_INSTALL_INC_DIR/$$sourcedir
		DEPENDPATH *= $$SOFA_INSTALL_INC_DIR/$$sourcedir
		LIBS *= -L$$SOFA_INSTALL_LIB_DIR
	}
	LIBS *= -l$$name$$LIBSUFFIX

	export(INCLUDEPATH)
	export(DEPENDPATH)
	export(LIBS)
}

##
# This function declares the existence of an artifact to the dependency manager.
# The artifact can be built from sources or just be an installed library. In the
# latter case it will not need dependencies, but the project path (relative to
# the root of the install include directory) will still be needed.
#
# Parameters:
#   name		the name of the artifact. It must match the TARGET variable in the pro file.
#		project	the path to the project file folder from the source root (or the
#			project file itself if it does not have the same name as its directory
#			(which is the default, recommended in Qt))
#		dependencies	a list of the name of other artifacts, also declared with this
#			function. Declaration order does not matter: the name of a dependent
#			artifact can be used before it is declared.
#
defineTest(declare) {
	artifact = $$1
	project = $$2
	dependencies = $$3

	eval($${artifact}.name = $$artifact)
	eval($${artifact}.project = $$project)
	eval($${artifact}.enabled = false)
	eval($${artifact}.deps = $$dependencies)

	artifacts_registry += $$artifact

#    message( "Registering $$artifact -> $$artifacts_registry" )

	export($${artifact}.name)
	export($${artifact}.project)
	export($${artifact}.enabled)
	export($${artifact}.deps)
	export(artifacts_registry)
}

defineTest(computeFlags) {
	artifact = $$1
	!isEmpty($${artifact}.flags): return (false)
	isEmpty($${artifact}.name): return (false)
    project = $$eval($${artifact}.project)
    clear(flags)
	# set flags
	match = $$find(project, ^.+\\.prf$)
	!isEmpty(match): flags *= file prf
	match = $$find(project, ^.+\\.pro$)
	!isEmpty(match): flags *= file pro
	exists($$FEATURES_DIR/$${artifact}.prf): flags *= installed

	contains(flags, file) {
		test_path = $$ROOT_SRC_DIR/$$project
	} else {
		flags *= dir
		dir = $$project 
		proname = $$basename(project).pro
		test_path = $$ROOT_SRC_DIR/$$project/$$basename(project).pro
	}
	exists($$test_path): {
		flags *= src
	}
	eval($${artifact}.flags = $$flags)
	export($${artifact}.flags)
#    message(FLAGS $$artifact: $$flags)
	return (true)
}


defineTest(hasFlag) {
	artifact = $$1
    flag = $$2
    computeFlags($$artifact)
    contains($${artifact}.flags,$$flag): return (true)
    else: return (false)
}


defineReplace(rootDeclarationsFile) {
	name = $$1

	exists($$FEATURES_DIR/$${name}.prf) {
		return ($$FEATURES_DIR/$$name)
	}
	else : exists($$ROOT_SRC_DIR/$${name}.prf) {
		return ($$ROOT_SRC_DIR/$$name)
	}
	else : error(root-declarations: cannot find $$name (FEATURES_DIR=$$FEATURES_DIR, ROOT_SRC_DIR=$$ROOT_SRC_DIR))
}

defineReplace(subDeclarationsFile) {
	name = $$1
	directory = $$2
    from = $$3

	exists($$FEATURES_DIR/$${name}.prf) {
		return ($$FEATURES_DIR/$$name)
	}
	else : exists($$ROOT_SRC_DIR/$$directory/$${name}.prf) {
		return ($$ROOT_SRC_DIR/$$directory/$$name)
	}
	else : exists($$directory/$${name}.prf) {
		return ($$directory/$$name)
	}
	else : error(sub-declarations: cannot find $$name used by $$from (dir=$$directory, FEATURES_DIR=$$FEATURES_DIR, ROOT_SRC_DIR=$$ROOT_SRC_DIR))
}

##
# This function set the group name of a given artifact
# This group can be used to sort artifacts into meaningfull categories
defineTest(addToBuildGroup) {
  group = $$1
  artifacts = $$2
  for(name, artifacts) {
    eval($${name}.group = $$group)
    export($${name}.group)
  }
}

##
# This function enables the compilation of the specified artifact.
#
# Parameters:
#		name	the name of the artifact (use "declare" first)
#
defineTest(enable) {
	name = $$1
	eval($${name}.enabled = true)
	export($${name}.enabled)
    # optimization: enabled deps and transitive dependencies are now computed immediately when enabling a project
    enabled_artifacts += $$name
    export(enabled_artifacts)
    # get the list of dependencies
    deps = $$eval($${name}.deps)
    # and the list of enabled transitive output artifacts
    tdeps_out = $$eval($${name}.tdeps_out)
    # filter the list of dependencies into disabled and enabled artifacts
    disabled_deps = $$deps
    disabled_deps -= $$enabled_artifacts
    enabled_deps = $$deps
    enabled_deps -= $$disabled_deps
    # save the list of enabled dependencies
    eval($${name}.enabled_deps = $$enabled_deps)
    export($${name}.enabled_deps)
    # compute the list of enabled transitive input artifacts
    # by merging the transitive input artifacts of our immediate dependencies
    tdeps_in = $$enabled_deps
    for(dep,enabled_deps) {
        tdeps_in *= $$eval($${dep}.tdeps_in)
    }
    # save the list of enabled transitive input artifacts
    eval($${name}.tdeps_in = $$tdeps_in)
    export($${name}.tdeps_in)
    # update the list of enabled transitive input artifacts of
    # all artifacts depending on us
    for(dep,tdeps_out) {
        eval($${dep}.tdeps_in *= $$name $$tdeps_in)
        export($${dep}.tdeps_in)
    }
    # update the list of enabled transitive output artifacts of
    # all artifacts we depend on, even the currently disabled ones
    for(dep,deps) {
        eval($${dep}.tdeps_out *= $$name $$tdeps_out)
        export($${dep}.tdeps_out)
    }
}

##
# This function returns the list of dependencies (including transitive ones) for
# the specified artifact.
#
# Parameters:
#		name	the name of the artifact
#
defineReplace(getEnabledTransitiveDependencies) {
	name = $$1
    tdeps_in = $$eval($${name}.tdeps_in)
    return ($$tdeps_in)
}

##
# This function generates the SUBDIRS configuration to build all enabled artifacts
# in the right order, using dependencies informations.
#
# Parameters:
#		none
#
defineTest(buildEnabledArtifacts) {
	for(artifact, enabled_artifacts) {
		hasFlag($$artifact, src):!hasFlag($$artifact, prf) {
			eval($${artifact}.srcdir = \$\$$${artifact}.project)
		}
	}
	for(artifact, enabled_artifacts) {
		project = $$eval($${artifact}.project)
		hasFlag($$artifact, src) {
			clear(deps_dirs)
			tdeps = $$getEnabledTransitiveDependencies($$artifact)
#           message(enabling $$artifact with the following dependencies:)
			for(dep, tdeps) {
#				message($$escape_expand(\\t)$$dep)
				deps_dirs *= $$eval($${dep}.srcdir)
			}
#            message(enabling $$artifact with the following dependencies: $$deps_dirs)

			addInstallableSubdir($$artifact, $$project, $$deps_dirs) 
		}
	}
}

##
# This function loads all declared dependencies for the current artifact.
# It will set the include path, the library path, and the library list to use
# all these dependencies.
#
# Parameters:
#   name the name of the current artifact
#   recursivity if the value is "transitive" it will also load transitive dependencies
#
defineTest(loadDependencies) {
	target = $$1
#    message(loadDependencies $$1)
	dependencies = $$getEnabledTransitiveDependencies($$target)
	for(dep, dependencies) {
		name = $$eval($${dep}.name)
		!equals(dep, $$name) {
             message("Declared artifacts: " $$artifacts_registry)
             message(undeclared dependency $$dep required by $$target)
        }
		project = $$eval($${dep}.project)
		hasFlag($$name,prf) {
			requireLib($$name, $$project)
		} else {
			equals($${dep}.enabled, true) {
				extsrc = $$find(project, ^extlibs/.+$)
				isEmpty(extsrc) {
					requireSofaLib($$name, $$project)
				} else {
					requireExtLib($$name, $$project)
				}
			}
		}
	}
#    message(loadDependencies $$1 END)
}

##
# This function imports all the declarations necessary to use or build the specified plugin.
#
defineTest(usePlugin) {
#    message(usePlugin $$1 $$2)
	plugin = $$1
    path = $$2
    isEmpty(path) : path = applications/plugins/$$plugin
    isEmpty($${plugin}.name) {
        load($$subDeclarationsFile($${plugin}-dependencies, $$path, $$plugin))
        eval($${plugin}.type = plugin)
        export($${plugin}.type)
    }
}

##
# This function imports all the declarations necessary to use or build the specified application.
#
defineTest(useApp) {
    project = $$1
    path = $$2
    load($$subDeclarationsFile($${project}-dependencies, $$path, $$project))
	eval($${project}.type = app)
	export($${project}.type)
}

##
# This function configures the current project file to build an artifact belonging
# to the specified plugin.
#
defineTest(defineAsPlugin) {
	PLUGIN_NAME = $$1
	TEMPLATE = lib
	usePlugin($$PLUGIN_NAME)
	export(TEMPLATE)
	export(PLUGIN_NAME)
}

##
# This function configures the current project file to build an artifact belonging
# to the specified application.
#
defineTest(defineAsApp) {
	APP_NAME = $$1
	TEMPLATE = app
	useApp($$APP_NAME, $$_PRO_FILE_PWD_)
	export(TEMPLATE)
	export(APP_NAME)
}

##
# This function export activated libraries and their
# dependencies as a graphviz file.
#
defineTest(outputBuildGraph) {
  outfile = $$1
  isEmpty(outfile) : outfile = Sofa-build.dot

  message(Generating $$outfile)

  system(echo "'digraph G {'" > $$outfile)
  system(echo "'node [fontsize=48];'" >> $$outfile)

  clear(clusters)
  for(artifact, artifacts_registry) {
    cluster = $$eval($${artifact}.group)
    isEmpty(cluster) {
      cluster = $$section($${artifact}.project, "/", 0, 1)
      cluster = $$replace(cluster, extlibs/.*, extlibs)
      equals($${artifact}.project, $$cluster): !equals(artifact, sofatests): cluster = system
    }
    cnode = $$cluster
    cnode = $$replace(cnode, /, _)
    cnode = $$replace(cnode, -, _)
    cnode = $$replace(cnode, \\..*, )
    clusters *= $$cnode
    eval(cluster_$${cnode}.name = $$cluster)
    eval(cluster_$${cnode}.artifacts *= $$artifact)
  }
  for(cnode, clusters) {
    cluster = $$eval(cluster_$${cnode}.name)
    cartifacts = $$eval(cluster_$${cnode}.artifacts)
    message($$cluster : $$cartifacts)
    system(echo "   subgraph cluster_$$cnode {" >> $$outfile)
    for(artifact, cartifacts) {
      anode = $$artifact
	  anode = $$replace(anode, -, _)
      ashape = rectangle
      acolor = orange
      equals($${artifact}.type, plugin) {
        ashape = hexagon
        acolor = gold
      }
      equals($${artifact}.type, app) {
        ashape = ellipse
        acolor = green
      }
      equals($${artifact}.enabled, true) {
        !hasFlag($$artifact,src): acolor = cyan
      }
      else {
        !hasFlag($$artifact,src):!hasFlag($$artifact,prf): acolor = red
        else: acolor = gray
      }
      
      system(echo "'    $$anode [label=\"$$artifact\",style=filled,color=$$acolor,shape=$$ashape];'" >> $$outfile)
    }
    system(echo "'    label=\"$$cluster\";'" >> $$outfile)
    system(echo "'    style=filled; color=blue; fillcolor=lightcyan; fontsize=48; penwidth=4; shape=box3d'" >> $$outfile)
    system(echo "  }" >> $$outfile)
  }
  for(artifact, artifacts_registry) {
    anode = $$artifact
    anode = $$replace(anode, -, _)
    deps = $$eval($${artifact}.deps) # Retrieve the dependencies of the current artifact
    enabled = $$eval($${artifact}.enabled)
    for(dep, deps) {
      dnode = $$dep
      dnode = $$replace(dnode, -, _)
      denabled = $$eval($${dep}.enabled)
      equals(enabled,true):equals(denabled,true) {
      system(echo "'  $$dnode -> $$anode [weight=10,  penwidth=2];'" >> $$outfile)
      }
      else {
      system(echo "'  $$dnode -> $$anode [color=gray];'" >> $$outfile)
      }
    }
  }
  system(echo "}" >> $$outfile)
}
